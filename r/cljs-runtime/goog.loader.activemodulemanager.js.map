{
"version":3,
"file":"goog.loader.activemodulemanager.js",
"lineCount":61,
"mappings":"AAAA,IAAA,CAAA,UAAA,CAAA,QAAA,CAAA,OAAA,CAAA;AAAA,cAAA;AAUAA,MAAKC,CAAAA,MAAL,CAAY,iCAAZ,CAAA;AACAD,MAAKC,CAAAA,MAAOC,CAAAA,sBAAZ,EAAA;AAEA,QAAMC,wBAAwBH,IAAKI,CAAAA,OAAL,CAAa,mCAAb,CAA9B;AACA,QAAMC,UAAUL,IAAKI,CAAAA,OAAL,CAAa,cAAb,CAAhB;AAGA,MAAIE,gBAAgB,IAApB;AAGA,MAAIC,aAAa,IAAjB;AAGA,MAAIC,qBAAqB,EAAzB;AAQAC,UAASA,UAAS,CAACC,WAAD,CAAc;AAC9B,QAAIJ,aAAJ;AACEI,iBAAA,CAAYJ,aAAZ,CAAA;AADF;AAGEE,wBAAmBG,CAAAA,IAAnB,CAAwBD,WAAxB,CAAA;AAHF;AAD8B;AAYhCE,UAASA,IAAG,EAAG;AACb,QAAI,CAACN,aAAL,IAAsBC,UAAtB;AACEM,SAAA,CAAIN,UAAA,EAAJ,CAAA;AADF;AAGAF,WAAQS,CAAAA,MAAR,CACIR,aADJ,IACqB,IADrB,EAC2B,0CAD3B,CAAA;AAEA,WAAOA,aAAP;AANa;AAefO,UAASA,IAAG,CAACE,gBAAD,CAAmB;AAC7BV,WAAQS,CAAAA,MAAR,CACIR,aADJ,IACqB,IADrB,EAC2B,yCAD3B,CAAA;AAEAA,iBAAA,GAAgBS,gBAAhB;AACAP,sBAAmBQ,CAAAA,OAAnB,CAA2BN,WAAA,IAAe;AACxCA,iBAAA,CAAmDJ,aAAnD,CAAA;AADwC,KAA1C,CAAA;AAGAE,sBAAA,GAAqB,EAArB;AAP6B;AAe/BS,UAASA,WAAU,CAACC,EAAD,CAAK;AACtBX,cAAA,GAAaW,EAAb;AADsB;AAQxBC,UAASA,qBAAoB,CAACC,EAAD,CAAK;AAChC,QAAId,aAAJ;AACEA,mBAAca,CAAAA,oBAAd,CAAmCC,EAAnC,CAAA;AADF;AADgC;AAYlCC,UAASA,UAAS,EAAG;AACnB,QAAIf,aAAJ;AACEA,mBAAce,CAAAA,SAAd,EAAA;AADF;AADmB;AAcrBC,UAASA,gBAAe,CAACC,IAAD,EAAOC,gBAAP,CAAyB;AAC/C,QAAI,CAAClB,aAAL,CAAoB;AAClB,UAAI,CAACC,UAAL;AAAiB;AAAjB;AACAM,SAAA,CAAIN,UAAA,EAAJ,CAAA;AAFkB;AAIpBD,iBAAcmB,CAAAA,sBAAd,CAAqCF,IAArC,EAA2CC,gBAA3C,CAAA;AAL+C;AASjD,QAAME,QAAQA,QAAQ,EAAG;AACvBpB,iBAAA,GAAgB,IAAhB;AACAE,sBAAA,GAAqB,EAArB;AAFuB,GAAzB;AAKAmB,SAAA,GAAU,CACRf,GADQ,EAERC,GAFQ,EAGRI,UAHQ,EAIRE,oBAJQ,EAKRE,SALQ,EAMRC,eANQ,EAORI,KAPQ,EAQRjB,SARQ,EAAV;AAzHA,SAAA,OAAA;AAAA,CAAA,CAAA;;",
"sources":["goog/loader/activemodulemanager.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A singleton interface for managing JavaScript code modules.\n */\n\ngoog.module('goog.loader.activeModuleManager');\ngoog.module.declareLegacyNamespace();\n\nconst AbstractModuleManager = goog.require('goog.loader.AbstractModuleManager');\nconst asserts = goog.require('goog.asserts');\n\n/** @type {?AbstractModuleManager} */\nlet moduleManager = null;\n\n/** @type {?function(): !AbstractModuleManager} */\nlet getDefault = null;\n\n/** @type {!Array<function(!AbstractModuleManager)>} */\nlet configureFunctions = [];\n\n/**\n * Applys a configuration function on moduleManager if it exists. Otherwise\n * store the configuration function inside of configureFunctions list so\n * that they can be applied when moduleManager is instantiated.\n * @param {function(!AbstractModuleManager)} configureFn\n */\nfunction configure(configureFn) {\n  if (moduleManager) {\n    configureFn(moduleManager);\n  } else {\n    configureFunctions.push(configureFn);\n  }\n}\n\n/**\n * Gets the active module manager, instantiating one if necessary.\n * @return {!AbstractModuleManager}\n */\nfunction get() {\n  if (!moduleManager && getDefault) {\n    set(getDefault());\n  }\n  asserts.assert(\n      moduleManager != null, 'The module manager has not yet been set.');\n  return moduleManager;\n}\n\n/**\n * Sets the active module manager. This should never be used to override an\n * existing manager.\n *\n * @param {!AbstractModuleManager} newModuleManager\n */\nfunction set(newModuleManager) {\n  asserts.assert(\n      moduleManager == null, 'The module manager cannot be redefined.');\n  moduleManager = newModuleManager;\n  configureFunctions.forEach(configureFn => {\n    configureFn(/** @type {!AbstractModuleManager} */ (moduleManager));\n  });\n  configureFunctions = [];\n}\n\n/**\n * Stores a callback that will be used  to get an AbstractModuleManager instance\n * if set() is not called before the first get() call.\n * @param {function(): !AbstractModuleManager} fn\n */\nfunction setDefault(fn) {\n  getDefault = fn;\n}\n\n/**\n * Method called just before module code is loaded.\n * @param {string} id Identifier of the module.\n */\nfunction beforeLoadModuleCode(id) {\n  if (moduleManager) {\n    moduleManager.beforeLoadModuleCode(id);\n  }\n}\n\n/**\n * Records that the currently loading module was loaded. Also initiates loading\n * the next module if any module requests are queued. This method is called by\n * code that is generated and appended to each dynamic module's code at\n * compilation time.\n */\nfunction setLoaded() {\n  if (moduleManager) {\n    moduleManager.setLoaded();\n  }\n}\n\n/**\n * Initialize the module manager.\n * @param {string=} info A string representation of the module dependency\n *      graph, in the form: module1:dep1,dep2/module2:dep1,dep2 etc.\n *     Where depX is the base-36 encoded position of the dep in the module list.\n * @param {!Array<string>=} loadingModuleIds A list of moduleIds that\n *     are currently being loaded.\n */\nfunction maybeInitialize(info, loadingModuleIds) {\n  if (!moduleManager) {\n    if (!getDefault) return;\n    set(getDefault());\n  }\n  moduleManager.setAllModuleInfoString(info, loadingModuleIds);\n}\n\n/** Test-only method for removing the active module manager. */\nconst reset = function() {\n  moduleManager = null;\n  configureFunctions = [];\n};\n\nexports = {\n  get,\n  set,\n  setDefault,\n  beforeLoadModuleCode,\n  setLoaded,\n  maybeInitialize,\n  reset,\n  configure,\n};\n"],
"names":["goog","module","declareLegacyNamespace","AbstractModuleManager","require","asserts","moduleManager","getDefault","configureFunctions","configure","configureFn","push","get","set","assert","newModuleManager","forEach","setDefault","fn","beforeLoadModuleCode","id","setLoaded","maybeInitialize","info","loadingModuleIds","setAllModuleInfoString","reset","exports"]
}
