{"version":3,"sources":["reval/type/cljs.cljs"],"mappings":";AAuBA,AAAA,CAAAA,uCAAA,OAAA;;AAAA,CAAAC,8BAAA,OAEE,WAAYC;AAAZ,AAAA,0FAAA,0EAAA,iBAGoC,AAACC,eAAKD,MACvC,sDAAA,tDAACE,iDAAoBF;;AAI1B,AAAA,CAAAF,uCAAA,UAAA;;AAAA,CAAAC,8BAAA,UAEE,WAAYC;AAAZ,AACE,6DAAA,tDAACE,iDAAoBF;;AAEzB,AAAA,CAAA,AAAA,sEAAAG,tEAAaC;;AAAb,CAAA,AAAA,AAAaA,uFAEX,WAAYJ;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,iEAAA,1DAACE,iDAAoBF;;AAEzB,AAAA,CAAA,AAAA,qEAAAG,rEAAaE;;AAAb,CAAA,AAAA,AAAaA,sFAEX,WAAYL;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,iEAAA,1DAACE,iDAAoBF;;AAKzB,AAAA,CAAAF,uCAAA,YAAA;;AAAA,CAAAC,8BAAA,YAEE,WAAYC;AAAZ,AACE,6DAAA,tDAACE,iDAAoBF;;AAOzB,AAAA,CAAAF,uCAAA,YAAA;;AAAA,CAAAC,8BAAA,YAAA,WAEcC;AAFd,AAGI,6DAAA,tDAACE,iDAAoBF;;AAEzB,AAAA,CAAAF,uCAAA,aAAA;;AAAA,CAAAC,8BAAA,aAAA,WAEcC;AAFd,AAGI,6DAAA,tDAACE,iDAAoBF;;AAIzB,AAAA,CAAA,AAAA,uEAAAG,vEAAaG;;AAAb,CAAA,AAAA,AAAaA,wFAEX,WAAYN;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,0CAAA,2CAAA,wDAAA,aAAA,sDAAA,IAAA,uDAAA,IAAA,gEAAA,xUAACO,qVAKAP;;AAEL,AAAA,CAAA,AAAA,sEAAAG,tEAAaK;;AAAb,CAAA,AAAA,AAAaA,uFAEX,WAAYR;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,0CAAA,2CAAA,wDAAA,eAAA,sDAAA,IAAA,uDAAA,IAAA,gEAAA,1UAACO,sVAKAP;;AAEL,AAAA,CAAA,AAAA,2EAAAG,3EAAaM;;AAAb,CAAA,AAAA,AAAaA,4FAEX,WAAYT;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,0CAAA,2CAAA,wDAAA,gBAAA,sDAAA,IAAA,uDAAA,IAAA,gEAAA,3UAACO,uVAKAP;;AAEL,AAAA,CAAA,AAAA,+EAAAG,/EAAaO;;AAAb,CAAA,AAAA,AAAaA,gGAEX,WAAYV;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,0CAAA,2CAAA,wDAAA,aAAA,sDAAA,IAAA,uDAAA,IAAA,gEAAA,xUAACO,oVAKAP;;AAEL,AAAA,CAAA,AAAA,mEAAAG,nEAAaQ;;AAAb,CAAA,AAAA,AAAaA,oFAEX,WAAYX;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,0CAAA,2CAAA,wDAAA,WAAA,sDAAA,IAAA,uDAAA,IAAA,gEAAA,tUAACO,kVAKAP;;AAEL,AAAA,CAAA,AAAA,gFAAAG,hFAAaS;;AAAb,CAAA,AAAA,AAAaA,iGAEX,WAAYZ;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,0CAAA,2CAAA,wDAAA,UAAA,sDAAA,KAAA,uDAAA,IAAA,gEAAA,tUAACO,kVAKAP;;AAQL,AAAA,CAAA,AAAA,iFAAAG,jFAAaU;;AAAb,CAAA,AAAA,AAAaA,kGAEX,WAAYb;AAAZ,AAAA,eAAA,XAAYA;AAAZ,AACE,yCAAA,2CAAA,wDAAA,UAAA,sDAAA,IAAA,uDAAA,IAAA,gEAAA,pUAACc,gVAKAd","names":["reval.type.protocol/hiccup-convertable","reval.type.protocol/to-hiccup","self","cljs.core/type","reval.type.ui.simplevalue/simplevalue->hiccup","cljs.core/PROTOCOL_SENTINEL","cljs.core/Keyword","cljs.core/Symbol","cljs.core/MapEntry","reval.type.ui.list/list->hiccup","cljs.core/LazySeq","cljs.core/IntegerRange","cljs.core/PersistentVector","cljs.core/List","cljs.core/PersistentHashSet","cljs.core/PersistentArrayMap","reval.type.ui.list/map->hiccup"],"sourcesContent":["(ns reval.type.cljs\n  \"converts clojurescript values to hiccup representation\"\n  (:require\n   [reval.type.protocol :refer [hiccup-convertable #_to-hiccup]]\n   [reval.type.ui.simplevalue :refer [simplevalue->hiccup]]\n   [reval.type.ui.list :refer [list->hiccup map->hiccup]]))\n\n;;; ** to-hiccupers for basic Clojure forms **\n\n;; A default, catch-all to-hiccuper that takes anything we don't know what to do with and calls str on it.\n\n;; https://grokbase.com/t/gg/clojure/121d2w4vhn/is-this-a-bug-extending-protocol-on-js-object\n;; david nolan:\n;; You should never extend js/Object.\n;; It's unfortunate since this means we can't currently use js/Object to\n;; provide default protocol implementations as we do in Clojure w/o fear of\n;; conflicts with JavaScript libraries.\n\n#_(extend-type js/Object\n    hiccup-convertable\n    (to-hiccup [self]\n      (simplevalue->hiccup self \"clj-unknown\")))\n\n(extend-type default\n  hiccup-convertable\n  (to-hiccup [self]\n    ; warning because pr-str still might look good,\n    ;(warnf \"to-hiccuping unknown cljs type: %s data: %s \" (type self) (pr-str self))\n    [:div.bg-red-500 \"unknown type: \" (type self)\n     (simplevalue->hiccup self \"clj-unknown\")]))\n\n; nil values are a distinct thing of their own\n\n(extend-type nil\n  hiccup-convertable\n  (to-hiccup [self]\n    (simplevalue->hiccup self \"clj-nil\")))\n\n(extend-type cljs.core/Keyword\n  hiccup-convertable\n  (to-hiccup [self]\n    (simplevalue->hiccup self \"clj-keyword\")))\n\n(extend-type cljs.core/Symbol\n  hiccup-convertable\n  (to-hiccup [self]\n    (simplevalue->hiccup self \"clj-symbol\")))\n\n; would be cool to be able to use meta data to switch between\n; if meta ^:br is set, then convert \\n to [:br] otherwise to-hiccup the string as it is.\n; however clojure does not support meta data for strings\n(extend-type string\n  hiccup-convertable\n  (to-hiccup [self]\n    (simplevalue->hiccup self \"clj-string\")))\n\n#_(extend-type char\n    hiccup-convertable\n    (to-hiccup [self]\n      (simplevalue->hiccup self \"clj-char\")))\n\n(extend-type number\n  hiccup-convertable\n  (to-hiccup [self]\n    (simplevalue->hiccup self \"clj-long\")))\n\n(extend-type boolean\n  hiccup-convertable\n  (to-hiccup [self]\n    (simplevalue->hiccup self \"clj-boolean\")))\n\n;; LIST\n\n(extend-type cljs.core/MapEntry\n  hiccup-convertable\n  (to-hiccup [self]\n    (list->hiccup\n     {:class \"clj-vector\"\n      :open \"[\"\n      :close  \"]\"\n      :separator  \", \"}\n     self)))\n\n(extend-type cljs.core/LazySeq\n  hiccup-convertable\n  (to-hiccup [self]\n    (list->hiccup\n     {:class \"clj-lazy-seq\"\n      :open  \"(\"\n      :close \")\"\n      :separator \" \"}\n     self)))\n\n(extend-type cljs.core/IntegerRange\n  hiccup-convertable\n  (to-hiccup [self]\n    (list->hiccup\n     {:class \"clj-int-range\"\n      :open  \"(\"\n      :close \")\"\n      :separator \" \"}\n     self)))\n\n(extend-type cljs.core/PersistentVector\n  hiccup-convertable\n  (to-hiccup [self]\n    (list->hiccup\n     {:class \"clj-vector\"\n      :open \"[\"\n      :close  \"]\"\n      :separator \" \"}\n     self)))\n\n(extend-type cljs.core/List\n  hiccup-convertable\n  (to-hiccup [self]\n    (list->hiccup\n     {:class \"clj-list\"\n      :open \"(\"\n      :close  \")\"\n      :separator \" \"}\n     self)))\n\n(extend-type cljs.core/PersistentHashSet\n  hiccup-convertable\n  (to-hiccup [self]\n    (list->hiccup\n     {:class \"clj-set\"\n      :open \"#{\"\n      :close  \"}\"\n      :separator  \" \"}\n     self)))\n\n;; MAPS\n\n;; When we to-hiccup a map we will map over its entries, which will yield key-value pairs represented as vectors. To to-hiccup\n;; the map we to-hiccup each of these key-value pairs with this helper function. They are to-hiccuped as list-likes with no\n;; bracketing. These will then be assembled in to a list-like for the whole map by the IPersistentMap to-hiccup function.\n\n(extend-type cljs.core/PersistentArrayMap\n  hiccup-convertable\n  (to-hiccup [self]\n    (map->hiccup\n     {:class \"clj-map\"\n      :open \"{\"\n      :close  \"}\"\n      :separator  \" \"}\n     self)))\n\n;; This still needs to be implemented:\n;; cljs.core/Range\n;; cljs.core/Var\n;; cljs.core/List\n;; cljs.core/PersistentTreeMap\n\n"],"x_google_ignoreList":[0]}