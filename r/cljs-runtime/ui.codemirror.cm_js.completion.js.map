{"version":3,"sources":["ui/codemirror/cm_js/completion.cljs"],"mappings":";AAiEA,2CAAA,3CAAKA;AAGL,8CAAA,9CAAOC,oGACJC,KAAKC,IAAIC;AADZ,AAEE,IAAMC,OAAK,6IAAA,7IAACC,4CAAI,AAAQ,WAAA,XAAQJ,eAAOE,WAAK,KAAAG,OAAY,0CAAA,zCAAKP;IACvDQ,UAAQ,yIAAA,zIAACF,4CAAI,AAAQ,AAAQJ,WAAKE,WAAK,KAAAG,OAAY,CAAA,IAASP;AADlE,AAAA,kDAAA,uDAAA,qDAAA,mDAAA,9FAEqBG,WACF,CAAGC,MAAI,AAACK,gBAAMJ,sEACdF,WACF,CAAGC,MAAI,AAACK,gBAAMD;;AAEjC,8CAAA,9CAAME,oGAAcC,GAAGC;AAAvB,AACE,OAAWD,YAAG,AAAA,qFAAQC,OAAO,AAAA,iFAAMA;;AAErC;;;uDAAA,vDAAOC,sHAEJF;AAFH,AAGE,IAAMG,MAAI,AAAYH;IAChBI,UAAQ,AAAQD;IAChBE,YAAU,AAAMF;IAChBG,aAAW,AAAUN,WAAGI;AAH9B,AAQE,oBAAME;AAAN,AAEE,OAAChB,4CAAagB,WAAWF,QAAQC;;AAFnC;;;AAIJ;;;iDAAA,jDAAME,0GAEHP;AAFH,AAGE,IAAMQ,aAAW,AAACN,qDAAsBF;AAAxC,AACE,OAACD,4CAAaC,GAAGQ;;AAErB,yDAAA,zDAAMC,0HACHT,GAAGU;AADN,AAEE,IAAMF,aAAW,AAACN,qDAAsBF;IAClCW,MAAI,AAASX;IACbY,QAAM,AAAA,qFAAQJ;IACdK,MAAI,AAAA,iFAAML;AAHhB,AAIE,AAAAM,0DAAAC,mCAAA,qDAAA,iCAAA,KAAA,IAAA,8CAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA,yBAAA,UAAA,hBAAyBJ,YAAYC,aAAaH;GAAlD,OAAA,KAAA,KAAA;;AACA,AAAeC,iBAAID,SACJ,AAACO,qBAAQL,OACT,AAACK,qBAAQJ;;AAP1B;;AAUF,2DAAA,mEAAAK,9HAAMG;AAAN,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;cAAAA,VAAiDG;SAAjD,AAAA3B,4CAAAwB,eAAA,hEAAyCnB;AAAzC,AACE,IAAMuB,OAAK,AAAChB,+CAAgBP;AAA5B,AACE,GAAI,AAACwB,uBAAOD;AACV,OAAAT,0DAAAC,mCAAA,qDAAA,iCAAA,KAAA,IAAA,8CAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA;GAAA,OAAA,KAAA,KAAA;;AACA,AACE,AAAAF,0DAAAC,mCAAA,wDAAA,iCAAA,KAAA,IAAA,8CAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA,qCAA4CO;GAA5C,OAAA,KAAA,KAAA;;AACA,mCAAA,mFAAA,tHAACE,2BAASH,kJAAkBC;;AAF9B;;;AAKN;;;sCAAA,8CAAAG,pFAAME,6FAEsBC;AAF5B,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAAP,4BAAAO;cAAAA,VAEmBL;SAFnB,AAAA3B,4CAAAgC,eAAA,hEAEW3B;AAFX,AAGE,AAAAc,0DAAAC,mCAAA,wDAAA,iCAAA,KAAA,IAAA,8CAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA;GAAA,OAAA,KAAA,MAAA;;AACA,oBAAMhB;AAAN,AACE,AAACqB,yDAA0BC;;AAD7B;;AAEA,OAAiBO","names":["ui.codemirror.cm-js.completion/wordChars","ui.codemirror.cm-js.completion/word-in-line","line","lno","cno","back","cljs.core.get","js/RegExp","forward","cljs.core/count","ui.codemirror.cm-js.completion/cm-get-range","cm","range","ui.codemirror.cm-js.completion/cm-current-word-range","pos","line-no","column-no","line-range","ui.codemirror.cm-js.completion/cm-current-word","word-range","ui.codemirror.cm-js.completion/cm-replace-current-word","new-word","doc","start","end","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","cljs.core/clj->js","p__54613","map__54614","cljs.core/--destructure-map","ui.codemirror.cm-js.completion/get-completion-candidates","context","word","cljs.core/empty?","ui.codemirror.fun/dispatch","p__54616","map__54617","ui.codemirror.cm-js.completion/hint","evt"],"sourcesContent":["(ns ui.codemirror.cm-js.completion\n  (:require\n   [taoensso.timbre :refer-macros [debug info warn]]\n   [cljs.reader]\n   [cljs.tools.reader]\n   [ui.codemirror.fun :refer [dispatch]]))\n\n#_(defn cycle-pos\n    \"Cycle through positions. Returns [active? new-pos].\n  count\n    total number of completions\n  current\n    current position\n  go-back?\n    should we be going in reverse\n  initial-active\n    if false, then we return not-active when wrapping around\"\n    [count current go-back? initial-active]\n    (if go-back?\n      (if (>= 0 current)\n        (if initial-active\n          [true (dec count)]\n          [false 0])\n        [true (dec current)])\n      (if (>= current (dec count))\n        (if initial-active\n          [true 0]\n          [false 0])\n        [true (inc current)])))\n\n#_(defn cycle-completions\n    \"Cycle through completions, changing the codemirror text accordingly. Returns\n  a new state map.\n  state\n    the current completion state\n  go-back?\n    whether to cycle in reverse (generally b/c shift is pressed)\n  cm\n    the codemirror instance\n  evt\n    the triggering event. it will be `.preventDefault'd if there are completions\n    to cycle through.\"\n    [{:keys [num pos active from to list initial-text] :as state}\n     go-back? cm evt]\n    (when (and state (or (< 1 (count list))\n                         (and (< 0 (count list))\n                              (not (= initial-text (get (first list) 2))))))\n      (.preventDefault evt)\n      (let [initial-active (= initial-text (get (first list) 2))\n            [active pos] (if active\n                           (cycle-pos num pos go-back? initial-active)\n                           [true (if go-back? (dec num) pos)])\n            text (if active\n                   (get (get list pos) 2)\n                   initial-text)]\n      ;; TODO don't replaceRange here, instead watch the state atom and react to\n      ;; that.\n        (.replaceRange cm text from to)\n        (assoc state\n               :pos pos\n               :active active\n               :to #js {:line (.-line from)\n                        :ch (+ (count text)\n                               (.-ch from))}))))\n\n(def wordChars\n  \"[^\\\\s\\\\(\\\\)\\\\[\\\\]\\\\{\\\\},`']*\")\n\n(defn- word-in-line\n  [line lno cno]\n  (let [back (get (.match (.slice line 0 cno) (js/RegExp. (str wordChars \"$\"))) 0)\n        forward (get (.match (.slice line cno) (js/RegExp. (str \"^\" wordChars))) 0)]\n    {:start #js {:line lno\n                 :ch (- cno (count back))}\n     :end #js {:line lno\n               :ch (+ cno (count forward))}}))\n\n(defn cm-get-range [cm range]\n  (.getRange cm (:start range) (:end range)))\n\n(defn- cm-current-word-range\n  \"Find the current 'word' according to CodeMirror's `wordChars' list\"\n  [cm]\n  (let [pos (.getCursor cm)\n        line-no (.-line pos)\n        column-no (.-ch pos)\n        line-range (.getLine cm line-no)]\n    ;; findWordAt doesn't work w/ clojure-parinfer mode\n    ;; (.findWordAt cm back)\n    ;(info \"cm-current-word \" \"line-no:\" line-no \"col no:\" column-no)\n    ;(info \"line: \" line-range)\n    (when line-range\n      ;(info \"line-range: \" line-range)\n      (word-in-line line-range line-no column-no))))\n\n(defn cm-current-word\n  \"Find the current 'word' according to CodeMirror's `wordChars' list\"\n  [cm]\n  (let [word-range (cm-current-word-range cm)]\n    (cm-get-range cm word-range)))\n\n(defn cm-replace-current-word\n  [cm new-word]\n  (let [word-range (cm-current-word-range cm)\n        doc (.getDoc cm)\n        start (:start word-range)\n        end (:end word-range)]\n    (info \"replacing range \" start \" - \" end \" with \" new-word)\n    (.replaceRange doc new-word\n                   (clj->js start)\n                   (clj->js end))\n    nil))\n\n(defn get-completion-candidates [{:keys [cm] :as context}]\n  (let [word (cm-current-word cm)]\n    (if (empty? word)\n      (warn \"no current word - cannot get hint!\")\n      (do\n        (debug \"getting code-completion for word: \" word)\n        (dispatch context [:cm/hint word])\n        true))))\n\n(defn hint\n  \"Get a new completion state.\"\n  [{:keys [cm] :as context} evt]\n  (debug \"hint-get .. \")\n  (when cm\n    (get-completion-candidates context))\n  (.preventDefault evt))\n\n\n"],"x_google_ignoreList":[0]}