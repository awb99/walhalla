{"version":3,"sources":["goldly/service/result.cljc"],"mappings":";AAOA,wCAAA,xCAAMA,wFACHC;AADH,AAEE,OAACC,qBACA,WAAKC;AAAL,AAAQ,GAAI,cAAAC,bAAUD;AACZ,IAAAE,WAAMF;IAANE,eAAA,EAAA,CAAAA,oBAAAD,oBAAA,AAAAC,aAAA;AAAA,AAAA,QAAAA;KAAA;AACOC;;;;AACLH;;;;AACFA;;GACVF;;AAEH,0CAAA,1CAAMM,4FAAmBC,EAAEC,MAAMC;AAAjC,AACE,AAAAC,0DAAAC,mCAAA,wDAAA,wBAAA,KAAA,GAAA,gDAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA,0CAAkDJ,MAAMC;GAAxD,OAAA,KAAA,MAAA;;AACA,IAAA,AACE,IAAMK,iBAAe,AAACf,sCAAgBS;AAAtC,AACE,AAAAE,0DAAAC,mCAAA,wDAAA,wBAAA,KAAA,GAAA,8CAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA,qBAA4BE;GAA5B,OAAA,KAAA,MAAA;;AACA,OAACC,sBAAOR,EAAE,AAAAS,2CAAA,iBAAAC,sBAAAC;IAAAD,0BAAA,EAAA,CAAAA,uBAAA,OAAA,iBAAAE,YAAA,AAAAC,0CAAA,mFAAA,AAAAC,kDAAA,AAAA,qFAAA,wBAAA,AAAA,uKAAA,AAAA,nSAAQP;AAAR,AAAA,AAAAI,uCAAAC;;AAAAA;KAAAF;IAAAK,mBAAA,AAAAC,kDAAAN;IAAAO,gCAAA,AAAAC,qDAAAR;AAAA,AAAA,oBAAAO;AAAA,IAAAE,WAAA,mFAAQZ;AAAR,AAAA,QAAAQ,iDAAAA,+CAAAI,YAAAJ,2BAAAI;;AAAAJ;;YAAA,AAAAK,PAAuBlB,uBAAQF;gBAH7C,QAAAM,JAK4Be;AAL5B,AAMI,OAAAlB,0DAAAC,mCAAA,uDAAA,wBAAA,KAAA,GAAA,gDAAA,qDAAA,KAAAC,gBAAA;AAAA,AAAA,0FAAA,gCAAwCgB;GAAxC,OAAA,KAAA,MAAA","names":["goldly.service.result/specter-resolve","specter-vector","clojure.walk/prewalk","x","cljs.core/Keyword","G__77971","com.rpl.specter/END","goldly.service.result/update-atom-where","a","where","result","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","e77972","where-resolved","cljs.core/reset!","com.rpl.specter.impl/compiled-setval*","info__76670__auto__","goldly.service.result/pathcache77974","info77975","com.rpl.specter.impl/magic-precompilation","com.rpl.specter.impl/->LocalSym","precompiled77976","com.rpl.specter.impl/cached-path-info-precompiled","dynamic?__76671__auto__","com.rpl.specter.impl/cached-path-info-dynamic?","G__77982","cljs.core/deref","e"],"sourcesContent":["(ns goldly.service.result\n  (:require\n   [clojure.walk :as walk]\n   [com.rpl.specter :refer [transform setval END]]\n   #?(:clj  [taoensso.timbre  :refer [debug debugf info infof warn error errorf]]\n      :cljs [taoensso.timbre :refer-macros [debug debugf info infof warn error errorf]])))\n\n(defn specter-resolve\n  [specter-vector]\n  (walk/prewalk\n   (fn [x] (if (keyword? x)\n             (case x\n               :END END\n               x)\n             x))\n   specter-vector))\n\n(defn update-atom-where [a where result]\n  (debugf \"updating atom where: %s with result: %s\" where result)\n  (try\n    (let [where-resolved (specter-resolve where)]\n      (debug \"specter resolved: \" where-resolved)\n      (reset! a (setval where-resolved result @a)))\n    (catch #?(:cljs :default\n              :clj Exception) e\n      (errorf \"update-atom-where: %s  ex: %s\" e))))"]}