{"version":3,"sources":["modular/encoding/transit.cljc"],"mappings":";AAeA,kCAAA,2CAAA,7EAAKA,wIAEF,AAACC,uGACA,AAAA,yFAAWC,qDACX,AAAA,yFAAWC;AAEf,kCAAA,2CAAA,7EAAKC,wIAEF,AAACH,uGAAM,AAAA,yFAAWI,mDACX,AAAA,yFAAWC","names":["modular.encoding.transit/decode","cljs.core.merge","modular.encoding.time/time-deserialization-handlers","modular.encoding.bidi/bidi-deserialization-handlers","modular.encoding.transit/encode","modular.encoding.time/time-serialization-handlers","modular.encoding.bidi/bidi-serialization-handlers"],"sourcesContent":["(ns modular.encoding.transit\n  (:require\n   [cognitect.transit :as transit]\n   [modular.encoding.bidi :as bidi]\n   [modular.encoding.time :as time])\n  #?(:clj (:import [java.io ByteArrayInputStream ByteArrayOutputStream])))\n\n; another encoding option:\n; https://nextjournal.com/schmudde/java-time\n\n; transit encoding is used in\n; - ring middleware (muuntaja)\n; - websocket (sente packer)\n; - cljs ajax requests ()\n\n(def decode\n  {:handlers\n   (merge\n    (:handlers time/time-deserialization-handlers)\n    (:handlers bidi/bidi-deserialization-handlers))})\n\n(def encode\n  {:handlers\n   (merge (:handlers time/time-serialization-handlers)\n          (:handlers bidi/bidi-serialization-handlers))})\n\n; todo: \n; (def ^:private default-readers {'ig/ref ref, 'ig/refset refset})\n; (defn read-string \"Read a config from a string of edn. Refs may be denotied by tagging keywords with #ig/ref.\" ([s] (read-string {:eof nil} s)) ([opts s] (let [readers (merge default-readers (:readers opts {}))] (edn/read-string (assoc opts :readers readers) s))))\n\n#?(:clj\n   (defn write-transit [data]\n     (let [out (ByteArrayOutputStream. 4096)\n           writer (transit/writer out :json encode)]\n       (transit/write writer data)\n       (.toString out))))\n\n#?(:clj\n   (defn string->stream\n     ([s] (string->stream s \"UTF-8\"))\n     ([s encoding]\n      (-> s\n          (.getBytes encoding)\n          (ByteArrayInputStream.)))))\n\n#?(:clj\n   (defn read-transit [json]\n     (let [in (string->stream json)\n           reader (transit/reader in :json decode)]\n       (transit/read reader))))\n\n#?(:clj\n   (defn spit-transit [filename data]\n     (->> (write-transit data)\n          (spit filename))))\n\n#?(:clj\n   (defn slurp-transit [filename]\n     (let [json (slurp filename)]\n       (read-transit json))))\n\n"],"x_google_ignoreList":[0]}